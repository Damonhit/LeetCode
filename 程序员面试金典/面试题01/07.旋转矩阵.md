**题目描述：(简单)**

给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。

不占用额外内存空间能否做到？

示例 1:
```
给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],
原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

示例 2:
```
给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
```

**思路**
我们以题目中的示例二
```
 5  1  9 11
 2  4  8 10
13  3  6  7
15 14 12 16
```
作为例子，分析将图像旋转 90 度之后，这些数字出现在什么位置。

对于矩阵中的第一行而言，在旋转后，它出现在倒数第一列的位置：
```
 5  1  9 11              x  x  x  5
 x  x  x  x   =旋转后=>   x  x  x  1
 x  x  x  x              x  x  x  9
 x  x  x  x              x  x  x 11
 ```
并且，第一行的第 xx 个元素在旋转后恰好是倒数第一列的第 xx 个元素。

对于矩阵中的第二行而言，在旋转后，它出现在倒数第二列的位置：
```
 x  x  x  x              x  x  2  x
 2  4  8 10   =旋转后=>   x  x  4  x
 x  x  x  x              x  x  8  x
 x  x  x  x              x  x 10  x
 ```
对于矩阵中的第三行和第四行同理。这样我们可以得到规律：

```对于矩阵中第 i 行的第 j 个元素，在旋转后，它出现在倒数第 i 列的第 j 个位置。```

我们将其翻译成代码。由于矩阵中的行列从 0 开始计数，因此对于矩阵中的元素 `matrix[row][col]`，在旋转后，它的新位置为 `matrixnew[col][n−row−1]`

方法一：使用辅助数组

方法二：翻转

我们还可以另辟蹊径，用翻转操作代替旋转操作。我们还是以题目中的示例二
```
 5  1  9 11
 2  4  8 10
13  3  6  7
15 14 12 16
```
作为例子，先将其通过水平轴翻转得到：
```
 5  1  9 11                 15 14 12 16
 2  4  8 10                 13  3  6  7
------------   =水平翻转=>   ------------
13  3  6  7                  2  4  8 10
15 14 12 16                  5  1  9 11
```
再根据主对角线 \ 翻转得到：
```
15 14 12 16                   15 13  2  5
13  3  6  7   =主对角线翻转=>  14  3  4  1
 2  4  8 10                   12  6  8  9
 5  1  9 11                   16  7 10 11
 ```
就得到了答案。这是为什么呢？对于水平轴翻转而言，我们只需要枚举矩阵上半部分的元素，和下半部分的元素进行交换，即

`matrix[row][col]→ 
水平轴翻转
 matrix[n−row−1][col]`

对于主对角线翻转而言，我们只需要枚举对角线左侧的元素，和右侧的元素进行交换，即

`matrix[row][col]→ 
主对角线翻转
 matrix[col][row]`

将它们联立即可得到：

`matrix[row][col]
→ 
水平轴翻转
matrix[n−row−1][col]
→ 
主对角线翻转
 matrix[col][n−row−1]`
​	
 
和关键等式：

`matrixnew[col][n−row−1]=matrix[row][col]`

是一致的。

**代码：**

```java
public void rotate(int[][] matrix) {
        int n = matrix.length;
        //水平翻转
        for(int i = 0;i < n/2 ;i++){
            for(int j = 0; j< n;j++){
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n-i-1][j];
                matrix[n-i-1][j] = temp;
            }
        }

        //对角线翻转
        for(int i = 0;i < n ;i++){
            for(int j = 0; j< i;j++){
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
    }

```
